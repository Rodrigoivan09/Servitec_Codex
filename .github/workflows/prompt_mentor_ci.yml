name: Prompt Mentor CI

on:
  push:
    branches: ["main"]
  pull_request:

jobs:
  security-scans:
    name: Security Scans (SpotBugs + ZAP)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    services:
      mariadb:
        image: mariadb:10.11
        env:
          MYSQL_ROOT_PASSWORD: ServitecRootP@ssw0rd!2025
          MYSQL_DATABASE: servitecdb
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h 127.0.0.1 -pServitecRootP@ssw0rd!2025"
          --health-interval=5s
          --health-timeout=3s
          --health-retries=20
    env:
      SPRING_DATASOURCE_URL: jdbc:mariadb://127.0.0.1:3306/servitecdb
      SPRING_DATASOURCE_USERNAME: root
      SPRING_DATASOURCE_PASSWORD: ServitecRootP@ssw0rd!2025
      SERVER_PORT: 8090
      SPRING_PROFILES_ACTIVE: docker
      QA_USERNAME: ${{ secrets.ZAP_QA_USER }}
      QA_PASSWORD: ${{ secrets.ZAP_QA_PASS }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Temurin JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - name: Build project (skip tests)
        run: ./mvnw -B -DskipTests clean package

      - name: Run SpotBugs (SAST)
        run: ./mvnw -B -DskipTests spotbugs:spotbugs

      - name: Upload SpotBugs report
        uses: actions/upload-artifact@v4
        with:
          name: spotbugs-report
          path: target/spotbugsXml.xml

      - name: Launch Servitec (background)
        run: |
          ./mvnw -q -DskipTests spring-boot:run \
            -Dspring-boot.run.profiles=${SPRING_PROFILES_ACTIVE} \
            -Dspring-boot.run.jvmArguments="-Dserver.port=${SERVER_PORT}" &
          echo $! > app.pid

      - name: Wait for application readiness
        run: |
          for i in {1..30}; do
            if curl -fsS http://127.0.0.1:${SERVER_PORT}/login > /dev/null; then
              echo "Servitec app is responsive";
              exit 0;
            fi
            echo "Waiting for application (${i}/30)..."
            sleep 5
          done
          echo "Application failed to start" >&2
          if [ -f app.pid ]; then
            kill $(cat app.pid) || true
          fi
          exit 1

      - name: Prepare security reports folder
        run: mkdir -p security-reports

      - name: Authenticate QA user (capture session cookie)
        run: |
          FALLBACK_QA_USER="5555555555"
          FALLBACK_QA_PASS="Contrase침a1#"

          if [ -z "$QA_USERNAME" ]; then
            echo "Advertencia: QA_USERNAME no definido en secrets; usando valor por defecto." >&2
            QA_USERNAME="$FALLBACK_QA_USER"
          fi

          if [ -z "$QA_PASSWORD" ]; then
            echo "Advertencia: QA_PASSWORD no definido en secrets; usando valor por defecto." >&2
            QA_PASSWORD="$FALLBACK_QA_PASS"
          fi

          LOGIN_PAGE=$(mktemp)
          curl -sS -c cookies.txt "http://127.0.0.1:${SERVER_PORT}/login" > "$LOGIN_PAGE"

          CSRF_TOKEN=$(python3 -c "import re, pathlib; html = pathlib.Path('$LOGIN_PAGE').read_text(); pattern = re.search(r'name=\"_csrf\"[^>]*value=\"([^\"]+)\"', html) or re.search(r'value=\"([^\"]+)\"[^>]*name=\"_csrf\"', html); print(pattern.group(1) if pattern else '')")

          if [ -z "$CSRF_TOKEN" ]; then
            echo "No se pudo extraer el token CSRF del formulario de login" >&2
            exit 1
          fi

          rm -f "$LOGIN_PAGE"

          RESPONSE_FILE=$(mktemp)
          curl -sS -i -c cookies.txt -b cookies.txt \
            -H "Content-Type: application/x-www-form-urlencoded" \
            --data "username=${QA_USERNAME}&password=${QA_PASSWORD}&_csrf=${CSRF_TOKEN}" \
            http://127.0.0.1:${SERVER_PORT}/login_sesion > "$RESPONSE_FILE"

          if ! grep -q "JSESSIONID" cookies.txt && ! grep -q "Set-Cookie: JSESSIONID" "$RESPONSE_FILE"; then
            echo "No se obtuvo JSESSIONID tras el login" >&2
            tail -n 20 "$RESPONSE_FILE" || true
            exit 1
          fi

          SESSION=$(grep JSESSIONID cookies.txt | tail -n1 | awk '{print $7}')
          if [ -z "$SESSION" ]; then
            SESSION=$(grep "Set-Cookie: JSESSIONID" "$RESPONSE_FILE" | tail -n1 | sed -E 's/.*JSESSIONID=([^;]+);.*/\1/')
          fi

          if [ -z "$SESSION" ]; then
            echo "No fue posible extraer el valor de JSESSIONID" >&2
            exit 1
          fi

          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -b cookies.txt http://127.0.0.1:${SERVER_PORT}/admin)
          if [ "$STATUS" != "200" ]; then
            echo "Advertencia: la verificaci칩n posterior al login devolvi칩 HTTP $STATUS" >&2
          fi

          echo "ZAP_SESSION=$SESSION" >> $GITHUB_ENV
          rm -f "$RESPONSE_FILE" cookies.txt

      - name: Run OWASP ZAP baseline (DAST)
        env:
          ZAP_SESSION: ${{ env.ZAP_SESSION }}
        run: |
          if [ -z "$ZAP_SESSION" ]; then
            echo "Cookie de sesi칩n no disponible; abortando ZAP" >&2
            exit 1
          fi

          ZAP_REPLACER="-config replacer.full_list(0).description=AuthCookie -config replacer.full_list(0).enabled=true -config replacer.full_list(0).matchtype=REQ_HEADER -config replacer.full_list(0).matchstr=Cookie -config replacer.full_list(0).regex=false -config replacer.full_list(0).replacement=JSESSIONID=${ZAP_SESSION}"

          docker pull ghcr.io/zaproxy/zaproxy:stable
          docker run --rm --network host \
            -v "$PWD/security-reports:/zap/wrk:rw" \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py -t "http://127.0.0.1:${SERVER_PORT}" -r zap-baseline-report.html -I -z "$ZAP_REPLACER" || true

          if [ ! -f security-reports/zap-baseline-report.html ]; then
            printf "<html><body><h1>ZAP baseline skipped</h1><p>%s</p></body></html>\n" "Report not generated; check application logs." > security-reports/zap-baseline-report.html
          fi

      - name: Upload ZAP baseline report
        uses: actions/upload-artifact@v4
        with:
          name: zap-baseline-report
          path: security-reports/zap-baseline-report.html

      - name: Stop Servitec app
        if: always()
        run: |
          if [ -f app.pid ]; then
            kill $(cat app.pid) || true
          fi
